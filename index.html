<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="Tower of Hanoi">
    <title>Tower of Hanoi [CG course]</title>
    <link rel="stylesheet" type="text/css" href="./lib/style.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head>

<body onload="init()">
    <table>
    <td>
        <canvas id="my-canvas" width="850" height="450">
            Your browser does not support canvas, please use another browser.
        </canvas>
    </td>

    <td>
        <button class="button" id="button-from1to2" type="button">1st &#10132; 2nd (or 'a')</button>
        <button class="button" id="button-from1to3" type="button">1st &#10132; 3rd (or 'q')</button>
        <br/>
        <br/>
        <button class="button" id="button-from2to1" type="button">2nd &#10132; 1st (or 'd')</button>
        <button class="button" id="button-from2to3" type="button">2nd &#10132; 3rd (or 's')</button>
        <br/>
        <br/>
        <button class="button" id="button-from3to1" type="button">3rd &#10132; 1st (or 't')</button>
        <button class="button" id="button-from3to2" type="button">3rd &#10132; 2nd (or 'f')</button>
    </td>

    </table>
    
    <table border="1" style="background-color: grey;">
        <tr>
            <td colspan="6">
                <input id="computeGeometricalNormals" type="checkbox">Compute geometrical normals <br>
                <input id="useNormalMaps" type="checkbox" checked>Use NM texture
            </td>
        </tr>
        <tr>
        <td><div style="text-align:center"><select id="lightEditNo" onchange="showLight(this.value);">
            <option value="LA">Light A</option>
            <option value="LB">Light B</option>
            <option value="LC">Light C</option>
        </select></div></td>
        <th colspan="2">Diffuse</th>
        <th colspan="2">Specular</th>
        </tr>
        <tr>
        <td rowspan="6">
    <div id="LA">
        <table border="1">
        <tr>
        <td><div id="LA11"><b>Type</b></div></td>
        <td><div id="LA12"><select id="LAlightType" onchange="showHideUI(this.id,this.value);">
            <option value="none">None</option>
            <option value="direct">Direct</option>
            <option value="point">Point</option>
            <option value="spot">Spot</option>
        </select></div></td>
        <td><div id="LA13">Color</div></td>
        <td><div id="LA14"><input type="color" id="LAlightColor" value="#ffffff"></div></td>
        </tr>
        <tr>
        <td><div id="LA21">Pos <i>x</i></div></td>
        <td><div id="LA22"><input type="range" min="-250" max="250" id="LAPosX"></div></td>
        <td><div id="LA23">Decay &beta;</div></td>
        <td><div id="LA24"><input type="range" min="0" max="2" id="LADecay"></div></td>
        </tr>
        <tr>
        <td><div id="LA31">Pos <i>y</i></div></td>
        <td><div id="LA32"><input type="range" min="-250" max="250" id="LAPosY"></div></td>
        <td><div id="LA33">Targe dist. <i>g</i></div></td>
        <td><div id="LA34"><input type="range" min="0" max="100" id="LATarget"></div></td>
        </tr>
        <tr>
        <td><div id="LA41">Pos <i>z</i></div></td>
        <td><div id="LA42"><input type="range" min="-250" max="250" id="LAPosZ"></div></td>
        <td><div id="LA43">Cone <i>out</i></div></td>
        <td><div id="LA44"><input type="range" min="0" max="150" id="LAConeOut"></div></td>
        </tr>
        <tr>
        <td><div id="LA51">Dir &theta;</div></td>
        <td><div id="LA52"><input type="range" min="0" max="180" id="LADirTheta"></div></td>
        <td><div id="LA53">Cone <i>in</i></div></td>
        <td><div id="LA54"><input type="range" min="0" max="100" id="LAConeIn"></div></td>
        </tr>
        <tr>
        <td><div id="LA61">Dir &phi;</div></td>
        <td><div id="LA62"><input type="range" min="-180" max="180" id="LADirPhi"></div></td>
        <td colspan="2">&nbsp;</td>
        </tr>
        </table>
    </div>
    <div id="LB" style="display:none">
        <table border="1">
        <tr>
        <td><div id="LB11"><b>Type</b></div></td>
        <td><div id="LB12"><select id="LBlightType" onchange="showHideUI(this.id,this.value);">
            <option value="none">None</option>
            <option value="direct">Direct</option>
            <option value="point">Point</option>
            <option value="spot">Spot</option>
        </select></div></td>
        <td><div id="LB13">Color</div></td>
        <td><div id="LB14"><input type="color" id="LBlightColor" value="#ffffff"></div></td>
        </tr>
        <tr>
        <td><div id="LB21">Pos <i>x</i></div></td>
        <td><div id="LB22"><input type="range" min="-250" max="250" id="LBPosX"></div></td>
        <td><div id="LB23">Decay &beta;</div></td>
        <td><div id="LB24"><input type="range" min="0" max="2" id="LBDecay"></div></td>
        </tr>
        <tr>
        <td><div id="LB31">Pos <i>y</i></div></td>
        <td><div id="LB32"><input type="range" min="-250" max="250" id="LBPosY"></div></td>
        <td><div id="LB33">Targe dist. <i>g</i></div></td>
        <td><div id="LB34"><input type="range" min="0" max="100" id="LBTarget"></div></td>
        </tr>
        <tr>
        <td><div id="LB41">Pos <i>z</i></div></td>
        <td><div id="LB42"><input type="range" min="-250" max="250" id="LBPosZ"></div></td>
        <td><div id="LB43">Cone <i>out</i></div></td>
        <td><div id="LB44"><input type="range" min="0" max="150" id="LBConeOut"></div></td>
        </tr>
        <tr>
        <td><div id="LB51">Dir &theta;</div></td>
        <td><div id="LB52"><input type="range" min="0" max="180" id="LBDirTheta"></div></td>
        <td><div id="LB53">Cone <i>in</i></div></td>
        <td><div id="LB54"><input type="range" min="0" max="100" id="LBConeIn"></div></td>
        </tr>
        <tr>
        <td><div id="LB61">Dir &phi;</div></td>
        <td><div id="LB62"><input type="range" min="-180" max="180" id="LBDirPhi"></div></td>
        <td colspan="2">&nbsp;</td>
        </tr>
        </table>
    </div>
    <div id="LC" style="display:none">
        <table border="1">
        <tr>
        <td><div id="LC11"><b>Type</b></div></td>
        <td><div id="LC12"><select id="LClightType" onchange="showHideUI(this.id,this.value);">
            <option value="none">None</option>
            <option value="direct">Direct</option>
            <option value="point">Point</option>
            <option value="spot">Spot</option>
        </select></div></td>
        <td><div id="LC13">Color</div></td>
        <td><div id="LC14"><input type="color" id="LClightColor" value="#ffffff"></div></td>
        </tr>
        <tr>
        <td><div id="LC21">Pos <i>x</i></div></td>
        <td><div id="LC22"><input type="range" min="-250" max="250" id="LCPosX"></div></td>
        <td><div id="LC23">Decay &beta;</div></td>
        <td><div id="LC24"><input type="range" min="0" max="2" id="LCDecay"></div></td>
        </tr>
        <tr>
        <td><div id="LC31">Pos <i>y</i></div></td>
        <td><div id="LC32"><input type="range" min="-250" max="250" id="LCPosY"></div></td>
        <td><div id="LC33">Targe dist. <i>g</i></div></td>
        <td><div id="LC34"><input type="range" min="0" max="100" id="LCTarget"></div></td>
        </tr>
        <tr>
        <td><div id="LC41">Pos <i>z</i></div></td>
        <td><div id="LC42"><input type="range" min="-250" max="250" id="LCPosZ"></div></td>
        <td><div id="LC43">Cone <i>out</i></div></td>
        <td><div id="LC44"><input type="range" min="0" max="150" id="LCConeOut"></div></td>
        </tr>
        <tr>
        <td><div id="LC51">Dir &theta;</div></td>
        <td><div id="LC52"><input type="range" min="0" max="180" id="LCDirTheta"></div></td>
        <td><div id="LC53">Cone <i>in</i></div></td>
        <td><div id="LC54"><input type="range" min="0" max="100" id="LCConeIn"></div></td>
        </tr>
        <tr>
        <td><div id="LC61">Dir &phi;</div></td>
        <td><div id="LC62"><input type="range" min="-180" max="180" id="LCDirPhi"></div></td>
        <td colspan="2">&nbsp;</td>
        </tr>
        </table>
    </div>
        </td>
        
        <td><div id="D11"><b>Type</b></div></td>
        <td><div id="D12"><select id="diffuseType" onchange="showHideUI(this.id,this.value);">
            <option value="none">None</option>
            <option value="lambert">Lambert</option>
            <option value="toon">Toon</option>
        </select></div></td>
        <td><div id="S11"><b>Type</b></div></td>
        <td><div id="S12"><select id="specularType" onchange="showHideUI(this.id,this.value);">
            <option value="none">None</option>
            <option value="phong">Phong</option>
            <option value="blinn">Blinn</option>
            <option value="toonP">Toon (Phong)</option>
            <option value="toonB">Toon (Blinn)</option>
        </select></div></td>
        </tr>
        <tr>
        <td><div id="D21">Color</div></td>
        <td><div id="D22"><input type="color" id="diffuseColor" value="#00ffff"></div></td>
        <td><div id="S21">Color</div></td>
        <td><div id="S22"><input type="color" id="specularColor" value="#ffffff"></div></td>
        </tr>
        <tr>
        <td><div id="D31">Texture</div></td>
        <td><div id="D32"><input type="range" min="0" max="100" id="DTexMix"></div></td>
        <td><div id="S31">Shiny &gamma;</div></td>
        <td><div id="S32"><input type="range" min="1" max="200" id="SpecShine"></div></td>
        </tr>
        <tr>
        <td><div id="D41">Toon thr.</div></td>
        <td><div id="D42"><input type="range" min="0" max="100" id="DToonTh"></div></td>
        <td><div id="S41">Toon thr.</div></td>
        <td><div id="S42"><input type="range" min="0" max="100" id="SToonTh"></div></td>
        </tr>
        <tr>
        <tr>
        <td colspan="2">
            <div style="text-align:center">
            <span onclick="resetShaderParams();">Reset</span>
            </div>
        </td>
        </tr>
    </table>

    <!--<script id="shadow-vs" type="not-js">
        attribute vec3 vPosition;
        uniform mat4 uMVP; // model-view-projection matrix

        void main(void) {
            gl_Position = uMVP * vec4(vPosition, 1.0); // compute position in light coordinate
        }
    </script>
    <script id="shadow-fs" type="not-js">
        #ifdef GL_ES
            precision highp float;
        #endif
        // we use a texture as the depth map and all channels of a texture (r, g, b and a) are 8-bit, so every point in
        // a texture is 32-bit. Float here is 16-bit, so if we utilize all 32 bits in a texture, it is quite sufficient.
        const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
        const vec4 bitMask = vec4(1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0, 0.0);

        void main(void) {
            vec4 rgbaDepth = fract(gl_FragCoord.z * bitShift);
            rgbaDepth -= rgbaDepth.gbaa * bitMask;
	        gl_FragColor = rgbaDepth;
        }
    </script>-->

    <!--<script id="ground-vs" type="not-js">
        attribute vec3 vPosition;
        uniform mat4 uMVP;
        uniform mat4 uMVPFromLight;
        varying vec4 vPositionFromLight;

        void main(void) {
            vPositionFromLight = uMVPFromLight * vec4(vPosition, 1.0); // compute position in light coordinate
            gl_Position = uMVP * vec4(vPosition, 1.0);
        }
    </script>
    <script id="ground-fs" type="not-js">
        /**
         * we do not use any texture to draw ground
         */
        #ifdef GL_ES
            precision highp float;
        #endif
        uniform vec3 uColor; // the ground's color
        uniform vec3 uLightColor;
        uniform sampler2D uShadowMap; // depth value in light coordinate
        uniform float uShadowMapResolution;
        varying vec4 vPositionFromLight;

        /**
         * compute z-value from a vec4
         */
        float unpackDepth(const in vec4 rgbaDepth) {
            const vec4 bitShift = vec4(1.0, 1.0 / 256.0, 1.0 / (256.0 * 256.0), 1.0 / (256.0 * 256.0 * 256.0));
            float depth = dot(rgbaDepth, bitShift);
            return depth;
        }

        /**
         * compute the visibility coefficient
         */
        float getVisibility(vec3 shadowCoordinate) {
            float sum = 0.0;
            // use a simple and incomplete but good enough percentage-closer filtering method.
            // take 16 points on shadow map as the sampler.
            for (float x = -1.5; x <= 1.5; x += 1.0) {
                for (float y = -1.5; y <= 1.5; y += 1.0) {
                    if(shadowCoordinate.z > 1.0) {
                        // coordinates outside the far plane of the light's orthographic frustum will never be in shadow
                        sum += 1.0;
                    } else {
                        vec2 biasedCoordinate = shadowCoordinate.xy + vec2(x, y) / uShadowMapResolution;
                        float depth = 1.0; // all coordinates outside the depth map's range have a default depth of 1.0
                        // which means these coordinates will never be in shadow since no object will have a depth larger than 1.0
                        if (biasedCoordinate.x >= 0.0 && biasedCoordinate.x <= 1.0 && biasedCoordinate.y >= 0.0 && biasedCoordinate.y <= 1.0) {
                            vec4 rgbaDepth = texture2D(uShadowMap, biasedCoordinate);
                            depth = unpackDepth(rgbaDepth); // decode the depth value from the depth map
                        }
                        sum += (shadowCoordinate.z > depth + 0.005) ? 0.5 : 1.0; // add 0.005 to eliminate Mach band, also known as shadow acne
                    }
                }
            }
            return sum / 16.0;
        }

        void main(void) {
            vec3 shadowCoordinate = (vPositionFromLight.xyz / vPositionFromLight.w) / 2.0 + 0.5;
            float visibility = getVisibility(shadowCoordinate);
            vec3 finalColor = clamp((uColor + uLightColor) / 2.0, 0.0, 1.0); // mix the ground's color and the light's color
	        gl_FragColor = vec4(visibility * finalColor, 1.0);
        }
    </script>-->

    <!--<script id="rod-vs" type="not-js">
        attribute vec3 vPosition;
        attribute vec3 vNormal;
        attribute vec2 vTexCoord;
        uniform mat4 uModelView;
        uniform mat4 uProjection;
        uniform mat4 uNormal;
        uniform mat4 uMVPFromLight;
        varying vec3 fNormal;
        varying vec3 fPosition;
        varying vec2 fTexCoord;
        varying vec4 vPositionFromLight;

        void main(void) {
            vPositionFromLight = uMVPFromLight * vec4(vPosition, 1.0); // compute position in light coordinate
            fNormal = (uNormal * vec4(vNormal, 1.0)).xyz; // normals in camera coordinate
            fPosition = (uModelView * vec4(vPosition, 1.0)).xyz; // vertex position in camera coordinate
            fTexCoord = vTexCoord;
            gl_Position = uProjection * uModelView * vec4(vPosition, 1.0);
        }
    </script>
    <script id="rod-fs" type="not-js">
        /**
         * we do use image texture to draw rods
         */
        #ifdef GL_ES
            precision highp float;
        #endif
        uniform vec3 uLightDirection;
        uniform vec3 uLightColor;
        uniform sampler2D uShadowMap; // depth value in light coordinate
        uniform sampler2D uTexSampler;
        varying vec3 fNormal;
        varying vec3 fPosition; // vertex position in camera coordinate
        varying vec2 fTexCoord;
        varying vec4 vPositionFromLight;

        /**
        * compute the Blinn-Phong shading model
        * @param lightDirection: the direction of the light in camera coordinate
        * @param lightIntensity: the intensity of the light
        * @param ambientCoefficient: the coefficient of ambient light
        * @param diffuseCoefficient: the coefficient of diffuse light
        * @param specularCoefficient: the coefficient of specular light
        * @param specularExponent: the lightiness of specular light
        * @return a 2D vector whose first element is the combination final coefficient of ambient light and diffuse
        * light while the second element is the final coefficient of specular light
        */
        vec2 blinnPhongShading(vec3 lightDirection, float lightIntensity, float ambientCoefficient,
            float diffuseCoefficient, float specularCoefficient, float specularExponent)
        {
            lightDirection = normalize(lightDirection);
            vec3 eyeDirection = normalize(-fPosition);
            vec3 normal = normalize(fNormal);
            vec3 halfVector = normalize(eyeDirection + lightDirection);
            float ambientAndDiffuse = ambientCoefficient + diffuseCoefficient * lightIntensity * max(0.0, dot(normal,
                lightDirection));
            float specular = specularCoefficient * pow(max(0.0, dot(normal, halfVector)), specularExponent);
            return vec2(ambientAndDiffuse, specular);
        }

        /**
         * compute z-value from a vec4
         */
        float unpackDepth(const in vec4 rgbaDepth) {
            const vec4 bitShift = vec4(1.0, 1.0 / 256.0, 1.0 / (256.0 * 256.0), 1.0 / (256.0 * 256.0 * 256.0));
            float depth = dot(rgbaDepth, bitShift);
            return depth;
        }

        void main(void) {
            vec3 shadowCoordinate = (vPositionFromLight.xyz / vPositionFromLight.w) / 2.0 + 0.5;
            vec4 rgbaDepth = texture2D(uShadowMap, shadowCoordinate.xy);
            float depth = unpackDepth(rgbaDepth); // decode the depth value from the depth map
            float visibility = (shadowCoordinate.z > depth + 0.00001) ? 0.7 : 1.0;
            vec2 light = blinnPhongShading(uLightDirection, 1.0, 0.5, 1.0, 1.5, 100.0);
            vec3 ambientAndDiffuseColor = light.x * texture2D(uTexSampler, fTexCoord).xyz;
            vec3 specularColor = light.y * uLightColor;
	        gl_FragColor = vec4(visibility * (ambientAndDiffuseColor + specularColor), 1.0);
        }
    </script>-->

    <!--<script id="disc-vs" type="not-js">
        attribute vec3 vPosition;
        attribute vec3 vNormal;
        uniform mat4 uModelView;
        uniform mat4 uProjection;
        uniform mat4 uNormal;
        uniform mat4 uMVPFromLight;
        varying vec3 fNormal;
        varying vec3 fPosition; // vertex position in camera coordinate
        varying vec3 uPosition; // pass on the original coordinate from the vertex shader to the fragment shader
        // for procedure texture
        varying vec4 vPositionFromLight;

        void main(void) {
            vPositionFromLight = uMVPFromLight * vec4(vPosition, 1.0); // compute position in light coordinate
            fNormal = (uNormal * vec4(vNormal, 1.0)).xyz; // normals in camera coordinate
            uPosition = vPosition; // vertex position in model coordinate
            fPosition = (uModelView * vec4(vPosition, 1.0)).xyz; // vertex position in camera coordinate
            gl_Position = uProjection * uModelView * vec4(vPosition, 1.0);
        }
    </script>
    <script id="disc-fs" type="not-js">
        /**
         * we use procedural texture to draw discs
         */
        #ifdef GL_ES
            precision highp float;
        #endif
        uniform vec3 uColor; // the object's color
        uniform vec3 uLightDirection;
        uniform vec3 uLightColor;
        uniform sampler2D uShadowMap; // depth value in light coordinate
        varying vec3 fNormal;
        varying vec3 fPosition;
        varying vec3 uPosition;
        varying vec4 vPositionFromLight;

        /**
         * a pulse function in order to make stripe
         */
        float pulse(float value, float destination) {
            return floor(mod(value * destination, 1.0) + 0.5);
        }

        /**
        * compute the Blinn-Phong shading model
        * @param lightDirection: the direction of the light in camera coordinate
        * @param lightIntensity: the intensity of the light
        * @param ambientCoefficient: the coefficient of ambient light
        * @param diffuseCoefficient: the coefficient of diffuse light
        * @param specularCoefficient: the coefficient of specular light
        * @param specularExponent: the lightiness of specular light
        * @return a 2D vector whose first element is the combination final coefficient of ambient light and diffuse
        * light while the second element is the final coefficient of specular light
        */
        vec2 blinnPhongShading(vec3 lightDirection, float lightIntensity, float ambientCoefficient,
            float diffuseCoefficient, float specularCoefficient, float specularExponent)
        {
            lightDirection = normalize(lightDirection);
            vec3 eyeDirection = normalize(-fPosition);
            vec3 normal = normalize(fNormal);
            vec3 halfVector = normalize(eyeDirection + lightDirection);
            float ambientAndDiffuse = ambientCoefficient + diffuseCoefficient * lightIntensity * max(0.0, dot(normal,
                lightDirection));
            float specular = specularCoefficient * pow(max(0.0, dot(normal, halfVector)), specularExponent);
            return vec2(ambientAndDiffuse, specular);
        }

        /**
         * compute z-value from a vec4
         */
        float unpackDepth(const in vec4 rgbaDepth) {
            const vec4 bitShift = vec4(1.0, 1.0 / 256.0, 1.0 / (256.0 * 256.0), 1.0 / (256.0 * 256.0 * 256.0));
            float depth = dot(rgbaDepth, bitShift);
            return depth;
        }

        void main(void) {
            vec3 shadowCoordinate = (vPositionFromLight.xyz / vPositionFromLight.w) / 2.0 + 0.5;
            vec4 rgbaDepth = texture2D(uShadowMap, shadowCoordinate.xy);
            float depth = unpackDepth(rgbaDepth); // decode the depth value from the depth map
            float visibility = (shadowCoordinate.z > depth + 0.00001) ? 0.7 : 1.0;
            vec2 light = blinnPhongShading(uLightDirection, 1.0, 0.5, 1.0, 1.5, 30.0);
            vec3 objectColor = (1.0 + 0.3 * pulse(uPosition.z, 0.1)) * uColor; // add some stripes
            vec3 ambientAndDiffuseColor = light.x * objectColor;
            vec3 specularColor = light.y * uLightColor;
	        gl_FragColor = vec4(visibility * (ambientAndDiffuseColor + specularColor), 1.0);
        }
    </script>-->

    <!-- always load libraries first-->
    <script src="./lib/Libraries/quaternion.min.js"></script>
    <script src="./lib/Libraries/twgl-full.js"></script>
    <script src="./lib/Libraries/jquery-3.3.1.js"></script>
    <script src="./lib/Libraries/utils.js"></script>
    <script src="./lib/Libraries/miscellaneousUtilities.js"></script>

    <!-- compile shaders and define how to create all objects in local coordinate-->
    <script src="./lib/Objects/textures/woodTexture.js"></script> <!-- load textures before loading object models-->
    <!--<script src="./lib/Objects/ground.js"></script>  prototype of ground-->
    <script src="./lib/Objects/rod.js"></script> <!-- prototype of rod-->
    <script src="./lib/Objects/disc.js"></script> <!-- prototype of disc-->
    <script src="./lib/Objects/allObjects.js"></script> <!-- define the initialize procedure to create 3 rods and 4 discs
    in terms of graphic models, so it should be loaded before main.js-->

    <!-- the game logic part-->
    <script src="./lib/gameLogic.js"></script> <!-- load gameLogic.js first-->
    <!--<script src="./lib/GameCore/AI.js"></script>-->

    <!-- user interaction methods-->
    <script src="./lib/UserInteraction/arcball.js"></script>
    <script src="./lib/UserInteraction/buttonClick.js"></script>
    <script src="./lib/UserInteraction/keyboard.js"></script>

    <!-- This should be loaded last, so please keep the order of loading JavaScript Files -->
    <script src="./lib/main.js"></script>
</body>
</html>
